syntax = "proto3";

import "google/protobuf/empty.proto";

option go_package = "github.com/cirruslabs/orchard/rpc";

service Controller {
  // message bus between the controller and a worker
  rpc Watch(google.protobuf.Empty) returns (stream WatchInstruction);

  // single purpose method when a port forward is requested and running
  // session information is passed in the requests metadata
  rpc PortForward(stream PortForwardData) returns (stream PortForwardData);

  // session information is passed in the requests metadata
  rpc Exec(stream ExecData) returns (stream ExecData);

  // worker calls this method when it has successfully resolved the VM's IP
  rpc ResolveIP(ResolveIPResult) returns (google.protobuf.Empty);
}

message WatchInstruction {
  message PortForward {
    // we can have multiple port forwards for the same vm/port pair
    // let's distinguish them by a unique session
    string session = 1;
    // can be empty to request port-forwarding to the worker itself
    string vm_uid = 2;
    uint32 port = 3;
  }
  message SyncVMs {
    // nothing for now
  }
  message ResolveIP {
    // we can have multiple IP resolution requests for the same vm
    // let's distinguish them by a unique session
    string session = 1;
    string vm_uid = 2;
  }
  message Exec {
    message TerminalSize {
      uint32 rows = 1;
      uint32 cols = 2;
    }

    // we can have multiple exec requests for the same vm
    // so use a session identifier
    string session = 1;
    string vm_uid = 2;
    string command = 3;
    repeated string args = 4;
    bool interactive = 5;
    bool tty = 6;
    TerminalSize terminal_size = 7;
  }

  oneof action {
    PortForward port_forward_action = 1;
    SyncVMs sync_vms_action = 2;
    ResolveIP resolve_ip_action = 3;
    Exec exec_action = 4;
  }
}

message PortForwardData {
  bytes data = 1;
}

message ExecData {
  bytes data = 1;
}

message ResolveIPResult {
  string session = 1;
  string ip = 2;
}
